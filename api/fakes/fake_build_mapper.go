// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/cnupp/appssdk/api"
)

type FakeBuildMapper struct {
	CreateStub        func(app api.App, params api.BuildParams) (build api.Build, apiErr error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		app    api.App
		params api.BuildParams
	}
	createReturns struct {
		result1 api.Build
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 api.Build
		result2 error
	}
	GetBuildsStub        func(app api.App) (builds api.Builds, apiErr error)
	getBuildsMutex       sync.RWMutex
	getBuildsArgsForCall []struct {
		app api.App
	}
	getBuildsReturns struct {
		result1 api.Builds
		result2 error
	}
	getBuildsReturnsOnCall map[int]struct {
		result1 api.Builds
		result2 error
	}
	GetBuildStub        func(app api.App, id string) (build api.Build, apiErr error)
	getBuildMutex       sync.RWMutex
	getBuildArgsForCall []struct {
		app api.App
		id  string
	}
	getBuildReturns struct {
		result1 api.Build
		result2 error
	}
	getBuildReturnsOnCall map[int]struct {
		result1 api.Build
		result2 error
	}
	UpdateStub        func(id string, params api.BuildParams) (updatedBuild api.Build, apiErr error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		id     string
		params api.BuildParams
	}
	updateReturns struct {
		result1 api.Build
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 api.Build
		result2 error
	}
	SuccessStub        func(build api.Build) (apiErr error)
	successMutex       sync.RWMutex
	successArgsForCall []struct {
		build api.Build
	}
	successReturns struct {
		result1 error
	}
	successReturnsOnCall map[int]struct {
		result1 error
	}
	FailStub        func(build api.Build) (apiErr error)
	failMutex       sync.RWMutex
	failArgsForCall []struct {
		build api.Build
	}
	failReturns struct {
		result1 error
	}
	failReturnsOnCall map[int]struct {
		result1 error
	}
	VerifySuccessStub        func(build api.Build) (apiErr error)
	verifySuccessMutex       sync.RWMutex
	verifySuccessArgsForCall []struct {
		build api.Build
	}
	verifySuccessReturns struct {
		result1 error
	}
	verifySuccessReturnsOnCall map[int]struct {
		result1 error
	}
	VerifyFailStub        func(build api.Build) (apiErr error)
	verifyFailMutex       sync.RWMutex
	verifyFailArgsForCall []struct {
		build api.Build
	}
	verifyFailReturns struct {
		result1 error
	}
	verifyFailReturnsOnCall map[int]struct {
		result1 error
	}
	CreateVerifyStub        func(build api.Build, params api.VerifyParams) (verify api.Verify, apiErr error)
	createVerifyMutex       sync.RWMutex
	createVerifyArgsForCall []struct {
		build  api.Build
		params api.VerifyParams
	}
	createVerifyReturns struct {
		result1 api.Verify
		result2 error
	}
	createVerifyReturnsOnCall map[int]struct {
		result1 api.Verify
		result2 error
	}
	GetVerifyStub        func(app api.App, build api.Build, id string) (verify api.Verify, apiErr error)
	getVerifyMutex       sync.RWMutex
	getVerifyArgsForCall []struct {
		app   api.App
		build api.Build
		id    string
	}
	getVerifyReturns struct {
		result1 api.Verify
		result2 error
	}
	getVerifyReturnsOnCall map[int]struct {
		result1 api.Verify
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBuildMapper) Create(app api.App, params api.BuildParams) (build api.Build, apiErr error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		app    api.App
		params api.BuildParams
	}{app, params})
	fake.recordInvocation("Create", []interface{}{app, params})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(app, params)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createReturns.result1, fake.createReturns.result2
}

func (fake *FakeBuildMapper) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeBuildMapper) CreateArgsForCall(i int) (api.App, api.BuildParams) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].app, fake.createArgsForCall[i].params
}

func (fake *FakeBuildMapper) CreateReturns(result1 api.Build, result2 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 api.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildMapper) CreateReturnsOnCall(i int, result1 api.Build, result2 error) {
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 api.Build
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 api.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildMapper) GetBuilds(app api.App) (builds api.Builds, apiErr error) {
	fake.getBuildsMutex.Lock()
	ret, specificReturn := fake.getBuildsReturnsOnCall[len(fake.getBuildsArgsForCall)]
	fake.getBuildsArgsForCall = append(fake.getBuildsArgsForCall, struct {
		app api.App
	}{app})
	fake.recordInvocation("GetBuilds", []interface{}{app})
	fake.getBuildsMutex.Unlock()
	if fake.GetBuildsStub != nil {
		return fake.GetBuildsStub(app)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBuildsReturns.result1, fake.getBuildsReturns.result2
}

func (fake *FakeBuildMapper) GetBuildsCallCount() int {
	fake.getBuildsMutex.RLock()
	defer fake.getBuildsMutex.RUnlock()
	return len(fake.getBuildsArgsForCall)
}

func (fake *FakeBuildMapper) GetBuildsArgsForCall(i int) api.App {
	fake.getBuildsMutex.RLock()
	defer fake.getBuildsMutex.RUnlock()
	return fake.getBuildsArgsForCall[i].app
}

func (fake *FakeBuildMapper) GetBuildsReturns(result1 api.Builds, result2 error) {
	fake.GetBuildsStub = nil
	fake.getBuildsReturns = struct {
		result1 api.Builds
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildMapper) GetBuildsReturnsOnCall(i int, result1 api.Builds, result2 error) {
	fake.GetBuildsStub = nil
	if fake.getBuildsReturnsOnCall == nil {
		fake.getBuildsReturnsOnCall = make(map[int]struct {
			result1 api.Builds
			result2 error
		})
	}
	fake.getBuildsReturnsOnCall[i] = struct {
		result1 api.Builds
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildMapper) GetBuild(app api.App, id string) (build api.Build, apiErr error) {
	fake.getBuildMutex.Lock()
	ret, specificReturn := fake.getBuildReturnsOnCall[len(fake.getBuildArgsForCall)]
	fake.getBuildArgsForCall = append(fake.getBuildArgsForCall, struct {
		app api.App
		id  string
	}{app, id})
	fake.recordInvocation("GetBuild", []interface{}{app, id})
	fake.getBuildMutex.Unlock()
	if fake.GetBuildStub != nil {
		return fake.GetBuildStub(app, id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBuildReturns.result1, fake.getBuildReturns.result2
}

func (fake *FakeBuildMapper) GetBuildCallCount() int {
	fake.getBuildMutex.RLock()
	defer fake.getBuildMutex.RUnlock()
	return len(fake.getBuildArgsForCall)
}

func (fake *FakeBuildMapper) GetBuildArgsForCall(i int) (api.App, string) {
	fake.getBuildMutex.RLock()
	defer fake.getBuildMutex.RUnlock()
	return fake.getBuildArgsForCall[i].app, fake.getBuildArgsForCall[i].id
}

func (fake *FakeBuildMapper) GetBuildReturns(result1 api.Build, result2 error) {
	fake.GetBuildStub = nil
	fake.getBuildReturns = struct {
		result1 api.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildMapper) GetBuildReturnsOnCall(i int, result1 api.Build, result2 error) {
	fake.GetBuildStub = nil
	if fake.getBuildReturnsOnCall == nil {
		fake.getBuildReturnsOnCall = make(map[int]struct {
			result1 api.Build
			result2 error
		})
	}
	fake.getBuildReturnsOnCall[i] = struct {
		result1 api.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildMapper) Update(id string, params api.BuildParams) (updatedBuild api.Build, apiErr error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		id     string
		params api.BuildParams
	}{id, params})
	fake.recordInvocation("Update", []interface{}{id, params})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(id, params)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateReturns.result1, fake.updateReturns.result2
}

func (fake *FakeBuildMapper) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeBuildMapper) UpdateArgsForCall(i int) (string, api.BuildParams) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].id, fake.updateArgsForCall[i].params
}

func (fake *FakeBuildMapper) UpdateReturns(result1 api.Build, result2 error) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 api.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildMapper) UpdateReturnsOnCall(i int, result1 api.Build, result2 error) {
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 api.Build
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 api.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildMapper) Success(build api.Build) (apiErr error) {
	fake.successMutex.Lock()
	ret, specificReturn := fake.successReturnsOnCall[len(fake.successArgsForCall)]
	fake.successArgsForCall = append(fake.successArgsForCall, struct {
		build api.Build
	}{build})
	fake.recordInvocation("Success", []interface{}{build})
	fake.successMutex.Unlock()
	if fake.SuccessStub != nil {
		return fake.SuccessStub(build)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.successReturns.result1
}

func (fake *FakeBuildMapper) SuccessCallCount() int {
	fake.successMutex.RLock()
	defer fake.successMutex.RUnlock()
	return len(fake.successArgsForCall)
}

func (fake *FakeBuildMapper) SuccessArgsForCall(i int) api.Build {
	fake.successMutex.RLock()
	defer fake.successMutex.RUnlock()
	return fake.successArgsForCall[i].build
}

func (fake *FakeBuildMapper) SuccessReturns(result1 error) {
	fake.SuccessStub = nil
	fake.successReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildMapper) SuccessReturnsOnCall(i int, result1 error) {
	fake.SuccessStub = nil
	if fake.successReturnsOnCall == nil {
		fake.successReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.successReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildMapper) Fail(build api.Build) (apiErr error) {
	fake.failMutex.Lock()
	ret, specificReturn := fake.failReturnsOnCall[len(fake.failArgsForCall)]
	fake.failArgsForCall = append(fake.failArgsForCall, struct {
		build api.Build
	}{build})
	fake.recordInvocation("Fail", []interface{}{build})
	fake.failMutex.Unlock()
	if fake.FailStub != nil {
		return fake.FailStub(build)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.failReturns.result1
}

func (fake *FakeBuildMapper) FailCallCount() int {
	fake.failMutex.RLock()
	defer fake.failMutex.RUnlock()
	return len(fake.failArgsForCall)
}

func (fake *FakeBuildMapper) FailArgsForCall(i int) api.Build {
	fake.failMutex.RLock()
	defer fake.failMutex.RUnlock()
	return fake.failArgsForCall[i].build
}

func (fake *FakeBuildMapper) FailReturns(result1 error) {
	fake.FailStub = nil
	fake.failReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildMapper) FailReturnsOnCall(i int, result1 error) {
	fake.FailStub = nil
	if fake.failReturnsOnCall == nil {
		fake.failReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.failReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildMapper) VerifySuccess(build api.Build) (apiErr error) {
	fake.verifySuccessMutex.Lock()
	ret, specificReturn := fake.verifySuccessReturnsOnCall[len(fake.verifySuccessArgsForCall)]
	fake.verifySuccessArgsForCall = append(fake.verifySuccessArgsForCall, struct {
		build api.Build
	}{build})
	fake.recordInvocation("VerifySuccess", []interface{}{build})
	fake.verifySuccessMutex.Unlock()
	if fake.VerifySuccessStub != nil {
		return fake.VerifySuccessStub(build)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.verifySuccessReturns.result1
}

func (fake *FakeBuildMapper) VerifySuccessCallCount() int {
	fake.verifySuccessMutex.RLock()
	defer fake.verifySuccessMutex.RUnlock()
	return len(fake.verifySuccessArgsForCall)
}

func (fake *FakeBuildMapper) VerifySuccessArgsForCall(i int) api.Build {
	fake.verifySuccessMutex.RLock()
	defer fake.verifySuccessMutex.RUnlock()
	return fake.verifySuccessArgsForCall[i].build
}

func (fake *FakeBuildMapper) VerifySuccessReturns(result1 error) {
	fake.VerifySuccessStub = nil
	fake.verifySuccessReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildMapper) VerifySuccessReturnsOnCall(i int, result1 error) {
	fake.VerifySuccessStub = nil
	if fake.verifySuccessReturnsOnCall == nil {
		fake.verifySuccessReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifySuccessReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildMapper) VerifyFail(build api.Build) (apiErr error) {
	fake.verifyFailMutex.Lock()
	ret, specificReturn := fake.verifyFailReturnsOnCall[len(fake.verifyFailArgsForCall)]
	fake.verifyFailArgsForCall = append(fake.verifyFailArgsForCall, struct {
		build api.Build
	}{build})
	fake.recordInvocation("VerifyFail", []interface{}{build})
	fake.verifyFailMutex.Unlock()
	if fake.VerifyFailStub != nil {
		return fake.VerifyFailStub(build)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.verifyFailReturns.result1
}

func (fake *FakeBuildMapper) VerifyFailCallCount() int {
	fake.verifyFailMutex.RLock()
	defer fake.verifyFailMutex.RUnlock()
	return len(fake.verifyFailArgsForCall)
}

func (fake *FakeBuildMapper) VerifyFailArgsForCall(i int) api.Build {
	fake.verifyFailMutex.RLock()
	defer fake.verifyFailMutex.RUnlock()
	return fake.verifyFailArgsForCall[i].build
}

func (fake *FakeBuildMapper) VerifyFailReturns(result1 error) {
	fake.VerifyFailStub = nil
	fake.verifyFailReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildMapper) VerifyFailReturnsOnCall(i int, result1 error) {
	fake.VerifyFailStub = nil
	if fake.verifyFailReturnsOnCall == nil {
		fake.verifyFailReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifyFailReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildMapper) CreateVerify(build api.Build, params api.VerifyParams) (verify api.Verify, apiErr error) {
	fake.createVerifyMutex.Lock()
	ret, specificReturn := fake.createVerifyReturnsOnCall[len(fake.createVerifyArgsForCall)]
	fake.createVerifyArgsForCall = append(fake.createVerifyArgsForCall, struct {
		build  api.Build
		params api.VerifyParams
	}{build, params})
	fake.recordInvocation("CreateVerify", []interface{}{build, params})
	fake.createVerifyMutex.Unlock()
	if fake.CreateVerifyStub != nil {
		return fake.CreateVerifyStub(build, params)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createVerifyReturns.result1, fake.createVerifyReturns.result2
}

func (fake *FakeBuildMapper) CreateVerifyCallCount() int {
	fake.createVerifyMutex.RLock()
	defer fake.createVerifyMutex.RUnlock()
	return len(fake.createVerifyArgsForCall)
}

func (fake *FakeBuildMapper) CreateVerifyArgsForCall(i int) (api.Build, api.VerifyParams) {
	fake.createVerifyMutex.RLock()
	defer fake.createVerifyMutex.RUnlock()
	return fake.createVerifyArgsForCall[i].build, fake.createVerifyArgsForCall[i].params
}

func (fake *FakeBuildMapper) CreateVerifyReturns(result1 api.Verify, result2 error) {
	fake.CreateVerifyStub = nil
	fake.createVerifyReturns = struct {
		result1 api.Verify
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildMapper) CreateVerifyReturnsOnCall(i int, result1 api.Verify, result2 error) {
	fake.CreateVerifyStub = nil
	if fake.createVerifyReturnsOnCall == nil {
		fake.createVerifyReturnsOnCall = make(map[int]struct {
			result1 api.Verify
			result2 error
		})
	}
	fake.createVerifyReturnsOnCall[i] = struct {
		result1 api.Verify
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildMapper) GetVerify(app api.App, build api.Build, id string) (verify api.Verify, apiErr error) {
	fake.getVerifyMutex.Lock()
	ret, specificReturn := fake.getVerifyReturnsOnCall[len(fake.getVerifyArgsForCall)]
	fake.getVerifyArgsForCall = append(fake.getVerifyArgsForCall, struct {
		app   api.App
		build api.Build
		id    string
	}{app, build, id})
	fake.recordInvocation("GetVerify", []interface{}{app, build, id})
	fake.getVerifyMutex.Unlock()
	if fake.GetVerifyStub != nil {
		return fake.GetVerifyStub(app, build, id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getVerifyReturns.result1, fake.getVerifyReturns.result2
}

func (fake *FakeBuildMapper) GetVerifyCallCount() int {
	fake.getVerifyMutex.RLock()
	defer fake.getVerifyMutex.RUnlock()
	return len(fake.getVerifyArgsForCall)
}

func (fake *FakeBuildMapper) GetVerifyArgsForCall(i int) (api.App, api.Build, string) {
	fake.getVerifyMutex.RLock()
	defer fake.getVerifyMutex.RUnlock()
	return fake.getVerifyArgsForCall[i].app, fake.getVerifyArgsForCall[i].build, fake.getVerifyArgsForCall[i].id
}

func (fake *FakeBuildMapper) GetVerifyReturns(result1 api.Verify, result2 error) {
	fake.GetVerifyStub = nil
	fake.getVerifyReturns = struct {
		result1 api.Verify
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildMapper) GetVerifyReturnsOnCall(i int, result1 api.Verify, result2 error) {
	fake.GetVerifyStub = nil
	if fake.getVerifyReturnsOnCall == nil {
		fake.getVerifyReturnsOnCall = make(map[int]struct {
			result1 api.Verify
			result2 error
		})
	}
	fake.getVerifyReturnsOnCall[i] = struct {
		result1 api.Verify
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildMapper) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.getBuildsMutex.RLock()
	defer fake.getBuildsMutex.RUnlock()
	fake.getBuildMutex.RLock()
	defer fake.getBuildMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.successMutex.RLock()
	defer fake.successMutex.RUnlock()
	fake.failMutex.RLock()
	defer fake.failMutex.RUnlock()
	fake.verifySuccessMutex.RLock()
	defer fake.verifySuccessMutex.RUnlock()
	fake.verifyFailMutex.RLock()
	defer fake.verifyFailMutex.RUnlock()
	fake.createVerifyMutex.RLock()
	defer fake.createVerifyMutex.RUnlock()
	fake.getVerifyMutex.RLock()
	defer fake.getVerifyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBuildMapper) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.BuildMapper = new(FakeBuildMapper)
